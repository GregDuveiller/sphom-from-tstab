---
title: "Exploring spatial homogeneity from temporal stability"
author: "Greg Duveiller"
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook describing the steps towards expanding the concept of **temporal signal-to-noise** ratio applied to MODIS NDVI daily time series described in [Duveiller et al. 2015](https://doi.org/10.1016/j.rse.2015.06.001). The idea is to extract a proxy for *spatial homogeneity* based on the *temporal stability* of the signal. The rational is that due to the large multi-angular resolution at which MODIS collects information, the spatial footprint of each observation varies from one day to the next. If it is stable, we can infer that the underlying surface is relatively homogeneous. 



First we load necessary libraries and the pre-computed synthetic dataset.
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)
library(raster)
load("~/Work/Workspace/spHomogeneity/dataProcessing/temp_workspace.RData")
col.1 <- '#1770DC'
col.2 <- '#DCA416'
col.3 <- 'grey20'
```


The synthetic dataset has two different classes that have a particular random spatial pattern with a given structure, and a determined temporal behaviour.
```{r}
plot(r, legend = FALSE, col = c(col.1,col.2))
ggplot(df.ideal.ts, aes(x = DOI)) + 
  geom_line(aes(y = DBF), colour = col.1) + 
  geom_line(aes(y = GRA), colour = col.2) +
  scale_y_continuous('NDVI') + scale_x_continuous('Day of the year (DOI)')
```

A MODIS point spread function model is applied to this data to simulate how the MODIS sensor *sees* this landscape. This model incorporates the changes in viewing angle along the 16-day revisit cycle of both the Terra and Aqua platform. As a result we have a value of purity for each land cover type at every date. This purity changes as shown below:
```{r}
#plot(purity_stack)
#df.purity <- as.data.frame(purity_stack, xy = T, long = T)

ggplot(df.purity) +
  geom_raster(aes(x = x, y = y, fill = value)) +
  facet_wrap(~factor(layer, levels = unique(df.purity$layer)), nc = 8) +
  scale_fill_viridis_c('Purity', option = 'C') +
  scale_x_continuous('') + scale_y_continuous('') +
  coord_equal(expand = c(0,0)) 
  
```


A random removal of observations is made to simulate cloud cover. 

We fit a spline to the remaining observations to estimate what the actual signal would be like. From there we can estimate three values for each time series:

- var_{res} : The variance of the residual
- var_{sig} : The variance of the modelled signal
- var_{tot} : The variance of the total time series

For every time series, we also have:

- pur_avg : the mean purity value over the time series
- pur_std : the standard deviation of the purity values 

Below we see how theses vary

```{r}
df.sum.long <- df.sum %>% 
  select(-pur_med) %>% 
  pivot_longer(cols = c('var_res','var_sig','var_tot'), 
                        names_to = 'var_type', values_to = 'value_var')

ggplot(df.sum.long %>% filter(pur_avg > 0.5),
       aes(x = pur_avg, y = value_var)) +
  geom_point(aes(colour = factor(original_id)), shape = 3) +
  geom_smooth(colour = col.3) + 
  facet_grid(var_type ~ ., scales = 'free_y') +
  #scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')
```


```{r}
ggplot(df.sum.long %>% filter(pur_avg > 0.5),
       aes(x = pur_std, y = value_var)) +
  geom_point(aes(colour = factor(original_id)), shape = 3) +
  geom_smooth(colour = col.3) + 
  facet_grid(var_type ~ ., scales = 'free_y') +
  #scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')
```

## Signal to Total ratio

```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5),
       aes(x = pur_avg, y = var_sig/var_tot)) +
  geom_point(aes(colour = factor(original_id)), shape = 3) +
  geom_smooth(colour = col.3) +
  #scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')

```

```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5),
       aes(x = pur_std, y = var_sig/var_tot)) +
  geom_point(aes(colour = factor(original_id)), shape = 3) +
  geom_smooth(colour = col.3) +
  #geom_smooth(colour = 'red', formula = y ~ poly(x,2)) +
  #scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')

```

```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5)) +
  geom_point(aes(x = pur_avg/pur_std, y = var_sig/var_tot,
                 colour = factor(original_id)),
             shape = 3) +
  scale_x_log10('log(pur_avg/pur_std)') +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')
```

## Signal to Noise ratio

```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5),
       aes(x = pur_avg, y = var_sig/var_res)) +
  geom_point(aes(colour = factor(original_id)), shape = 3) +
  geom_smooth(colour = col.3) +
  # scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')

```

```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5),
       aes(x = pur_std, y = var_sig/var_res)) +
  geom_point(aes(colour = factor(original_id)), shape = 3) +
  geom_smooth(colour = col.3) +
  scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')

```
  


```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5)) +
  geom_point(aes(x = pur_avg/pur_std, y = var_sig/var_res,
                 colour = factor(original_id)),
             shape = 3) +
    scale_x_log10() +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')

```



```{r}
ggplot(df.sum %>% filter(pur_avg > 0.5)) +
  geom_point(aes(x = pur_std, y = var_res,
                 colour = factor(original_id)),
             shape = 3) +
  geom_smooth(aes(x = pur_std, y = var_res), method = 'lm', 
              formula = y ~ poly(x, 2), color = 'grey20') +
  scale_colour_manual(values = c('1' = col.1, '0' = col.2), guide = 'none')

```